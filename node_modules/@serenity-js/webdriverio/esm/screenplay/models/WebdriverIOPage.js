import 'webdriverio';
import { List, LogicError } from '@serenity-js/core';
import { ArgumentDehydrator, BrowserWindowClosedError, ByCss, Key, Page, PageElement, PageElementsLocator } from '@serenity-js/web';
import * as scripts from '@serenity-js/web/lib/scripts/index.js';
import { URL } from 'url';
import { WebdriverIOExistingElementLocator, WebdriverIOLocator, WebdriverIORootLocator } from './locators/index.js';
import { WebdriverIOCookie } from './WebdriverIOCookie.js';
import { WebdriverIOPageElement } from './WebdriverIOPageElement.js';
/**
 * WebdriverIO-specific implementation of [`Page`](https://serenity-js.org/api/web/class/Page/).
 *
 * @group Models
 */
export class WebdriverIOPage extends Page {
    browser;
    errorHandler;
    lastScriptExecutionSummary;
    /* eslint-disable unicorn/consistent-function-scoping */
    dehydrator = new ArgumentDehydrator((item) => item instanceof PageElement, (item) => item.nativeElement());
    /* eslint-enable */
    constructor(session, browser, modalDialogHandler, errorHandler, pageId) {
        super(session, new WebdriverIORootLocator(browser), modalDialogHandler, pageId);
        this.browser = browser;
        this.errorHandler = errorHandler;
    }
    createPageElement(nativeElement) {
        return new WebdriverIOPageElement(new WebdriverIOExistingElementLocator(this.rootLocator, new ByCss(String(nativeElement.selector)), this.errorHandler, nativeElement));
    }
    locate(selector) {
        return new WebdriverIOPageElement(new WebdriverIOLocator(this.rootLocator, selector, this.errorHandler));
    }
    locateAll(selector) {
        return List.of(new PageElementsLocator(new WebdriverIOLocator(this.rootLocator, selector, this.errorHandler)));
    }
    async navigateTo(destination) {
        await this.inContextOfThisPage(() => this.browser.url(destination));
    }
    async navigateBack() {
        await this.inContextOfThisPage(() => this.browser.back());
    }
    async navigateForward() {
        await this.inContextOfThisPage(() => this.browser.forward());
    }
    async reload() {
        await this.inContextOfThisPage(() => this.browser.refresh());
    }
    async sendKeys(keys) {
        const keySequence = keys.map(key => {
            if (!Key.isKey(key)) {
                return key;
            }
            return key.utf16codePoint;
        });
        await this.inContextOfThisPage(() => this.browser.keys(keySequence));
    }
    async executeScript(script, ...args) {
        const serialisedScript = typeof script === 'function'
            ? String(script)
            : String(`function script() { ${script} }`);
        const executableScript = new Function(`
            var parameters = (${scripts.rehydrate}).apply(null, arguments);
            return (${serialisedScript}).apply(null, parameters);
        `);
        const result = await this.inContextOfThisPage(async () => {
            const dehydratedArguments = await this.dehydrator.dehydrate(args);
            return await this.browser.execute(executableScript, ...dehydratedArguments);
        });
        this.lastScriptExecutionSummary = new LastScriptExecutionSummary(result);
        return result;
    }
    async executeAsyncScript(script, ...args) {
        const serialisedScript = typeof script === 'function'
            ? String(script)
            : String(`function script() { ${script} }`);
        const executableScript = new Function(`
            var args = Array.prototype.slice.call(arguments, 0, -1);
            var callback = arguments[arguments.length - 1];
            var parameters = (${scripts.rehydrate}).apply(null, args);
            (${serialisedScript}).apply(null, parameters.concat(callback));
        `);
        const result = await this.inContextOfThisPage(async () => {
            const dehydratedArguments = await this.dehydrator.dehydrate(args);
            return this.browser.executeAsync(executableScript, ...dehydratedArguments);
        });
        this.lastScriptExecutionSummary = new LastScriptExecutionSummary(result);
        return result;
    }
    lastScriptExecutionResult() {
        if (!this.lastScriptExecutionSummary) {
            throw new LogicError(`Make sure to execute a script before checking on the result`);
        }
        // Selenium returns `null` when the script it executed returns `undefined`
        // so we're mapping the result back.
        return this.lastScriptExecutionSummary.result === null
            ? undefined
            : this.lastScriptExecutionSummary.result;
    }
    async takeScreenshot() {
        return await this.inContextOfThisPage(async () => {
            try {
                return await this.browser.takeScreenshot();
            }
            catch (error) {
                if (error.name === 'ProtocolError' && error.message.includes('Target closed')) {
                    throw new BrowserWindowClosedError(`Couldn't take screenshot since the browser window is already closed`, error);
                }
                throw error;
            }
        });
    }
    async cookie(name) {
        return new WebdriverIOCookie(this.browser, name);
    }
    async setCookie(cookieData) {
        return await this.inContextOfThisPage(() => {
            return this.browser.setCookies({
                name: cookieData.name,
                value: cookieData.value,
                path: cookieData.path,
                domain: cookieData.domain,
                secure: cookieData.secure,
                httpOnly: cookieData.httpOnly,
                expiry: cookieData.expiry
                    ? cookieData.expiry.toSeconds()
                    : undefined,
                sameSite: cookieData.sameSite,
            });
        });
    }
    async deleteAllCookies() {
        return await this.inContextOfThisPage(() => {
            return this.browser.deleteCookies();
        });
    }
    async title() {
        return await this.inContextOfThisPage(() => this.browser.getTitle());
    }
    async name() {
        return await this.inContextOfThisPage(() => this.browser.execute(`return window.name`));
    }
    async url() {
        return await this.inContextOfThisPage(async () => {
            return new URL(await this.browser.getUrl());
        });
    }
    async viewportSize() {
        return await this.inContextOfThisPage(async () => {
            if (!this.browser.isDevTools) {
                const calculatedViewportSize = await this.browser.execute(`
                    return {
                        width:  Math.max(document.documentElement.clientWidth,  window.innerWidth || 0),
                        height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
                    }
                `);
                // Chrome headless hard-codes window.innerWidth and window.innerHeight to 0
                if (calculatedViewportSize.width > 0 && calculatedViewportSize.height > 0) {
                    return calculatedViewportSize;
                }
            }
            return this.browser.getWindowSize();
        });
    }
    async setViewportSize(size) {
        return await this.inContextOfThisPage(async () => {
            let desiredWindowSize = size;
            if (!this.browser.isDevTools) {
                desiredWindowSize = await this.browser.execute(`
                    var currentViewportWidth  = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
                    var currentViewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                    
                    return {
                        width:  Math.max(window.outerWidth  - currentViewportWidth  + ${size.width},  ${size.width}),
                        height: Math.max(window.outerHeight - currentViewportHeight + ${size.height}, ${size.height}),
                    };
                `);
            }
            return this.browser.setWindowSize(desiredWindowSize.width, desiredWindowSize.height);
        });
    }
    async close() {
        await this.inContextOfThisPage(() => this.browser.closeWindow());
    }
    async closeOthers() {
        await this.session.closePagesOtherThan(this);
    }
    async isPresent() {
        const allPages = await this.session.allPages();
        for (const page of allPages) {
            if (page === this) {
                return true;
            }
        }
        return false;
    }
    async inContextOfThisPage(action) {
        let originalCurrentPage;
        try {
            originalCurrentPage = await this.session.currentPage();
            await this.session.changeCurrentPageTo(this);
            return await action();
        }
        catch (error) {
            return await this.errorHandler.executeIfHandled(error, action);
        }
        finally {
            await this.session.changeCurrentPageTo(originalCurrentPage);
        }
    }
}
/**
 * @package
 */
class LastScriptExecutionSummary {
    result;
    constructor(result) {
        this.result = result;
    }
}
//# sourceMappingURL=WebdriverIOPage.js.map