"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebdriverIOBrowsingSession = void 0;
require("webdriverio");
const core_1 = require("@serenity-js/core");
const index_js_1 = require("@serenity-js/core/lib/model/index.js");
const web_1 = require("@serenity-js/web");
const index_js_2 = require("../models/index.js");
const WebdriverIOErrorHandler_js_1 = require("./WebdriverIOErrorHandler.js");
const WebdriverIOModalDialogHandler_js_1 = require("./WebdriverIOModalDialogHandler.js");
const WebdriverIOPuppeteerModalDialogHandler_js_1 = require("./WebdriverIOPuppeteerModalDialogHandler.js");
/**
 * WebdriverIO-specific implementation of [`BrowsingSession`](https://serenity-js.org/api/web/class/BrowsingSession/).
 *
 * @group Models
 */
class WebdriverIOBrowsingSession extends web_1.BrowsingSession {
    browser;
    constructor(browser) {
        super();
        this.browser = browser;
        if (!browser.$ || !browser.$$) {
            throw new core_1.LogicError(`WebdriverIO browser object is not initialised yet, so can't be assigned to an actor. Are you trying to instantiate an actor outside of a test or a test hook?`);
        }
    }
    async allPages() {
        // scan all the active window handles and add any newly opened windows if needed
        const windowHandles = await this.browser.getWindowHandles();
        // remove pages that are no longer open
        const closedPageIds = this.registeredPageIds()
            .filter(id => !windowHandles.includes(id.value));
        this.deregister(...closedPageIds);
        // add any new pages that might have been opened (e.g. popup windows)
        const registeredWindowHandles = new Set(this.registeredPageIds().map(id => id.value));
        const newlyOpenedWindowHandles = windowHandles.filter(windowHandle => !registeredWindowHandles.has(windowHandle));
        for (const newlyOpenedWindowHandle of newlyOpenedWindowHandles) {
            const errorHandler = new WebdriverIOErrorHandler_js_1.WebdriverIOErrorHandler();
            this.register(new index_js_2.WebdriverIOPage(this, this.browser, await this.modalDialogHandlerFor(newlyOpenedWindowHandle, errorHandler), errorHandler, new index_js_1.CorrelationId(newlyOpenedWindowHandle)));
        }
        return super.allPages();
    }
    /**
     * @param page
     */
    async changeCurrentPageTo(page) {
        const currentPage = await this.currentPage();
        // are we already on this page?
        if (currentPage.id.equals(page.id)) {
            return void 0;
        }
        // does the new page exist, or has it been closed in the meantime by user action, script, or similar?
        if (!await page.isPresent()) {
            return void 0;
        }
        // the page seems to be legit, switch to it
        await this.browser.switchToWindow(page.id.value);
        // and update the cached reference
        await super.changeCurrentPageTo(page);
    }
    async activeWindowHandle() {
        try {
            return await this.browser.getWindowHandle();
        }
        catch (error) {
            // If the window is closed by user action Webdriver will still hold the reference to the closed window.
            if (['NoSuchWindowError', 'no such window'].includes(error.name)) {
                const allHandles = await this.browser.getWindowHandles();
                if (allHandles.length > 0) {
                    const handle = allHandles.at(-1);
                    await this.browser.switchToWindow(handle);
                    return handle;
                }
            }
            throw error;
        }
    }
    async currentPage() {
        const actualCurrentPageHandle = await this.activeWindowHandle();
        const actualCurrentPageId = index_js_1.CorrelationId.fromJSON(actualCurrentPageHandle);
        if (this.currentBrowserPage && this.currentBrowserPage.id.equals(actualCurrentPageId)) {
            return this.currentBrowserPage;
        }
        // Looks like the actual current page is not what we thought the current page was.
        // Is it one of the pages we are aware of?
        const allPages = await this.allPages();
        const found = allPages.find(page => page.id.equals(actualCurrentPageId));
        if (found) {
            this.currentBrowserPage = found;
            return this.currentBrowserPage;
        }
        // OK, so that's a handle that we haven't seen before, let's register it and set as current page.
        this.currentBrowserPage = await this.registerCurrentPage();
        return this.currentBrowserPage;
    }
    async registerCurrentPage() {
        const windowHandle = await this.browser.getWindowHandle();
        const errorHandler = new WebdriverIOErrorHandler_js_1.WebdriverIOErrorHandler();
        const page = new index_js_2.WebdriverIOPage(this, this.browser, await this.modalDialogHandlerFor(windowHandle, errorHandler), errorHandler, new index_js_1.CorrelationId(windowHandle));
        this.register(page);
        return page;
    }
    async modalDialogHandlerFor(windowHandle, errorHandler) {
        return this.browser.isDevTools
            ? new WebdriverIOPuppeteerModalDialogHandler_js_1.WebdriverIOPuppeteerModalDialogHandler(await this.puppeteerPageFor(windowHandle))
            : new WebdriverIOModalDialogHandler_js_1.WebdriverIOModalDialogHandler(this.browser, errorHandler);
    }
    async puppeteerPageFor(windowHandle) {
        const puppeteer = await this.browser.getPuppeteer();
        const pages = await puppeteer.pages();
        const handles = await this.browser.getWindowHandles();
        if (handles.length !== pages.length) {
            throw new core_1.LogicError(`The number of registered Puppeteer pages doesn't match WebdriverIO window handles`);
        }
        const index = handles.indexOf(windowHandle);
        // We cast to `unknown` first because the version of Page in Puppeteer-core
        // might be slightly out-of-sync with what the WebdriverIO uses.
        // This doesn't really matter since we're only using it to work with Dialogs.
        const page = pages[index];
        if (!page) {
            throw new core_1.LogicError(`Couldn't find Puppeteer page for WebdriverIO window handle ${windowHandle}`);
        }
        return page;
    }
    browserCapabilities() {
        return Promise.resolve(this.browser.capabilities);
    }
}
exports.WebdriverIOBrowsingSession = WebdriverIOBrowsingSession;
//# sourceMappingURL=WebdriverIOBrowsingSession.js.map