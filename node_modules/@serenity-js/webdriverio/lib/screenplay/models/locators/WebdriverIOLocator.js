"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebdriverIOExistingElementLocator = exports.WebdriverIOLocator = void 0;
require("webdriverio");
const core_1 = require("@serenity-js/core");
const web_1 = require("@serenity-js/web");
const WebdriverIOPageElement_js_1 = require("../WebdriverIOPageElement.js");
/**
 * WebdriverIO-specific implementation of [`Locator`](https://serenity-js.org/api/web/class/Locator/).
 *
 * @group Models
 */
class WebdriverIOLocator extends web_1.Locator {
    errorHandler;
    constructor(parent, selector, errorHandler) {
        super(parent, selector);
        this.errorHandler = errorHandler;
    }
    // todo: refactor; replace with a map and some more generic lookup mechanism
    nativeSelector() {
        if (this.selector instanceof web_1.ByCss) {
            return this.selector.value;
        }
        if (this.selector instanceof web_1.ByDeepCss) {
            return `>>> ${this.selector.value}`;
        }
        if (this.selector instanceof web_1.ByCssContainingText) {
            return `${this.selector.value}*=${this.selector.text}`;
        }
        if (this.selector instanceof web_1.ById) {
            return `#${this.selector.value}`;
        }
        if (this.selector instanceof web_1.ByTagName) {
            return `<${this.selector.value} />`;
        }
        if (this.selector instanceof web_1.ByXPath) {
            return this.selector.value;
        }
        throw new core_1.LogicError((0, core_1.f) `${this.selector} is not supported by ${this.constructor.name}`);
    }
    async isPresent() {
        try {
            const element = await this.resolveNativeElement();
            return Boolean(element);
        }
        catch {
            return false;
        }
    }
    async nativeElement() {
        try {
            return await this.resolveNativeElement();
        }
        catch (error) {
            return await this.errorHandler.executeIfHandled(error, () => this.resolveNativeElement());
        }
    }
    async resolveNativeElement() {
        const parent = await this.parent.nativeElement();
        if (parent.error) {
            throw parent.error;
        }
        const element = await parent.$(this.nativeSelector());
        if (element.error) {
            throw element.error;
        }
        return element;
    }
    async allNativeElements() {
        const parent = await this.parent.nativeElement();
        return parent.$$(this.nativeSelector());
    }
    of(parent) {
        return new WebdriverIOLocator(parent, this.selector, this.errorHandler);
    }
    closestTo(child) {
        return new WebdriverIOParentElementLocator(this.parent, this.selector, child, this.errorHandler);
    }
    locate(child) {
        return new WebdriverIOLocator(this, child.selector, this.errorHandler);
    }
    element() {
        return new WebdriverIOPageElement_js_1.WebdriverIOPageElement(this);
    }
    async allElements() {
        const elements = await this.allNativeElements();
        return elements.map(childElement => new WebdriverIOPageElement_js_1.WebdriverIOPageElement(new WebdriverIOExistingElementLocator(this.parent, this.selector, this.errorHandler, childElement)));
    }
}
exports.WebdriverIOLocator = WebdriverIOLocator;
/**
 * @internal
 */
class WebdriverIOExistingElementLocator extends WebdriverIOLocator {
    existingNativeElement;
    constructor(parentRoot, selector, errorHandler, existingNativeElement) {
        super(parentRoot, selector, errorHandler);
        this.existingNativeElement = existingNativeElement;
    }
    async nativeElement() {
        return this.existingNativeElement;
    }
    async allNativeElements() {
        return [this.existingNativeElement];
    }
}
exports.WebdriverIOExistingElementLocator = WebdriverIOExistingElementLocator;
class WebdriverIOParentElementLocator extends WebdriverIOLocator {
    child;
    constructor(parentRoot, selector, child, errorHandler) {
        super(parentRoot, selector, errorHandler);
        this.child = child;
    }
    async resolveNativeElement() {
        const cssSelector = this.asCssSelector(this.selector);
        const child = await this.child.nativeElement();
        if (child.error) {
            throw child.error;
        }
        return child.$(
        /* c8 ignore next */
        new Function(`return this.closest(\`${cssSelector.value}\`)`));
    }
    async allNativeElements() {
        return [await this.nativeElement()];
    }
}
//# sourceMappingURL=WebdriverIOLocator.js.map