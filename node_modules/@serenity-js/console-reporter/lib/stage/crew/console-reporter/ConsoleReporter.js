"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleReporter = void 0;
const core_1 = require("@serenity-js/core");
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const chalk_1 = require("chalk"); // eslint-disable-line unicorn/import-style
const tiny_types_1 = require("tiny-types");
const Printer_1 = require("./Printer");
const Summary_1 = require("./Summary");
const SummaryFormatter_1 = require("./SummaryFormatter");
const themes_1 = require("./themes");
/**
 * A [`StageCrewMember`](https://serenity-js.org/api/core/interface/StageCrewMember/) that uses [standard output](https://en.wikipedia.org/wiki/Standard_streams)
 * to report on progress of your Serenity/JS acceptance tests.
 *
 * `ConsoleReporter` ships with colour themes for both dark and light terminals,
 * as well as a monochromatic theme for those moments when you're in a noir mood
 * (or have a terminal that doesn't support colours, like the good old `cmd.exe` on Windows).
 *
 * ## Registering Console Reporter programmatically
 *
 * ```ts
 *  import { configure } from '@serenity-js/core';
 *  import { ConsoleReporter } from '@serenity-js/console-reporter';
 *
 *  configure({
 *    crew: [
 *      ConsoleReporter.withDefaultColourSupport()
 *    ],
 *  });
 * ```
 *
 * ## Redirecting output to a file
 *
 * ```ts
 *  import { configure } from '@serenity-js/core';
 *  import { ConsoleReporter } from '@serenity-js/console-reporter';
 *  import { createWriteStream } from 'fs';
 *
 *  configure({
 *    outputStream: createWriteStream('./output.log'),
 *    crew: [ ConsoleReporter.withDefaultColourSupport() ],
 *  });
 *  ```
 *
 * ## Registering Console Reporter with Playwright Test
 *
 * ```ts
 * // playwright.config.ts
 * import { devices } from '@playwright/test';
 * import type { PlaywrightTestConfig } from '@serenity-js/playwright-test';
 *
 * const config: PlaywrightTestConfig = {
 *
 *   reporter: [
 *     [ 'line' ],
 *     [ 'html', { open: 'never' } ],
 *     [ '@serenity-js/playwright-test', {
 *       crew: [
 *         '@serenity-js/console-reporter',
 *       ]
 *     }]
 *   ],
 * }
 * ```
 *
 * ## Registering Console Reporter with WebdriverIO
 *
 * ```ts
 * // wdio.conf.ts
 * import { ConsoleReporter } from '@serenity-js/console-reporter';
 * import { WebdriverIOConfig } from '@serenity-js/webdriverio';
 *
 * export const config: WebdriverIOConfig = {
 *
 *   framework: '@serenity-js/webdriverio',
 *
 *   serenity: {
 *     crew: [
 *       '@serenity-js/console-reporter',
 *     ]
 *     // other Serenity/JS config
 *   },
 *
 *  // other WebdriverIO config
 * }
 * ```
 *
 * ## Registering Console Reporter with Protractor
 *
 * ```js
 * // protractor.conf.js
 * const { ConsoleReporter } = require('@serenity-js/console-reporter');
 *
 * exports.config = {
 *   framework:     'custom',
 *   frameworkPath: require.resolve('@serenity-js/protractor/adapter'),
 *
 *   serenity: {
 *     crew: [
 *       '@serenity-js/console-reporter',
 *     ],
 *     // other Serenity/JS config
 *   },
 *
 *   // other Protractor config
 * }
 * ```
 *
 * ## Changing the default colour theme
 *
 * ```js
 *   // ...
 *   serenity: {
 *     crew: [
 *       [ '@serenity-js/console-reporter', {
 *         theme: 'light',
 *         // theme: 'dark',
 *         // theme: 'mono',
 *         // theme: 'auto',
 *       } ]
 *     ],
 *   },
 *   //...
 * ```
 *
 * @public
 *
 * @group Stage
 */
class ConsoleReporter {
    printer;
    theme;
    stage;
    startTimes = new StartTimes();
    artifacts = new ActivityRelatedArtifacts();
    summary = new Summary_1.Summary();
    firstErrors = new Map();
    summaryFormatter;
    eventQueues = new core_1.DomainEventQueues();
    static fromJSON(config) {
        return new ConsoleReporterBuilder(ConsoleReporter.theme(config.theme));
    }
    /**
     * Instantiates a `ConsoleReporter` that auto-detects
     * your terminal's support for colours and uses a colour theme
     * for dark terminals if successful.
     *
     * Please note that spawning your test process from another process
     * (by using [npm-failsafe](https://www.npmjs.com/package/npm-failsafe), for example)
     * causes the `ConsoleReporter` to use the monochromatic colour scheme,
     * as colour support can't be detected in child processes.
     */
    static withDefaultColourSupport() {
        return new ConsoleReporterBuilder(ConsoleReporter.theme('auto'));
    }
    /**
     * Instantiates a `ConsoleReporter` with a monochromatic colour theme.
     * Good for terminals with no colour support (like the `cmd.exe` on Windows),
     * or for times when you need to pipe the output to a text file and want
     * to avoid printing control characters.
     */
    static forMonochromaticTerminals() {
        return new ConsoleReporterBuilder(ConsoleReporter.theme('mono'));
    }
    /**
     * Instantiates a `ConsoleReporter` with a colour theme optimised for terminals with dark backgrounds.
     */
    static forDarkTerminals() {
        return new ConsoleReporterBuilder(ConsoleReporter.theme('dark'));
    }
    /**
     * Instantiates a `ConsoleReporter` with a colour theme optimised for terminals with light backgrounds.
     */
    static forLightTerminals() {
        return new ConsoleReporterBuilder(ConsoleReporter.theme('light'));
    }
    static theme(theme) {
        switch (theme) {
            case 'dark':
                return new themes_1.ThemeForDarkTerminals(new chalk_1.Instance({ level: 2 }));
            case 'light':
                return new themes_1.ThemeForLightTerminals(new chalk_1.Instance({ level: 2 }));
            case 'mono':
                return new themes_1.ThemeForMonochromaticTerminals();
            default:
                return new themes_1.ThemeForDarkTerminals(new chalk_1.Instance( /* auto-detect */));
        }
    }
    /**
     * @param {Printer} printer
     * @param {TerminalTheme} theme
     * @param {Stage} [stage=undefined]
     */
    constructor(printer, theme, stage) {
        this.printer = printer;
        this.theme = theme;
        this.stage = stage;
        (0, tiny_types_1.ensure)('printer', printer, (0, tiny_types_1.isDefined)());
        (0, tiny_types_1.ensure)('theme', theme, (0, tiny_types_1.isDefined)());
        this.summaryFormatter = new SummaryFormatter_1.SummaryFormatter(this.theme);
    }
    /**
     * Handles [`DomainEvent`](https://serenity-js.org/api/core-events/class/DomainEvent/) objects emitted by the [`Stage`](https://serenity-js.org/api/core/class/Stage/).
     *
     * @see [`StageCrewMember`](https://serenity-js.org/api/core/interface/StageCrewMember/)
     *
     * @listens {DomainEvent}
     *
     * @param {DomainEvent} event
     */
    notifyOf(event) {
        if (event instanceof events_1.TestRunStarts) {
            this.summary.recordTestRunStartedAt(event.timestamp);
        }
        if (this.isSceneSpecific(event)) {
            this.eventQueues.enqueue(event);
        }
        if (event instanceof events_1.SceneStarts) {
            this.firstErrors.set(event.sceneId.value, new FirstError());
            this.startTimes.recordStartOf(event);
        }
        if (event instanceof events_1.SceneFinished) {
            this.printScene(event.sceneId);
        }
        if (event instanceof events_1.TestRunFinished) {
            this.summary.recordTestRunFinishedAt(event.timestamp);
            this.printSummary(this.summary);
            if (event.outcome instanceof model_1.ProblemIndication) {
                this.printTestRunErrorOutcome(event.outcome);
            }
        }
    }
    printTestRunErrorOutcome(outcome) {
        this.printer.println(this.theme.outcome(outcome, outcome.error.stack));
    }
    printScene(sceneId) {
        const events = this.eventQueues.drainQueueFor(sceneId);
        for (const event of events) {
            (0, tiny_types_1.match)(event)
                .when(events_1.SceneStarts, (e) => {
                const category = e.details.name.value ? `${e.details.category.value}: ` : '';
                // Print scenario header
                this.printer.println(this.theme.separator('-'));
                this.printer.println(e.details.location.path.value, e.details.location.line ? `:${e.details.location.line}` : '');
                this.printer.println();
                this.printer.println(this.theme.heading(category, e.details.name.value));
                this.printer.println();
            })
                .when(events_1.TaskStarts, (e) => {
                this.printer.indent();
                if (!this.firstErrors.get(e.sceneId.value)?.alreadyRecorded()) {
                    this.printer.println(e.details.name.value);
                }
            })
                .when(events_1.InteractionStarts, (e) => {
                this.startTimes.recordStartOf(e);
            })
                .when(events_1.InteractionFinished, (e) => {
                this.printer.indent();
                this.printer.println(this.formattedOutcome(e));
                this.printer.indent();
                if (e.outcome instanceof model_1.ProblemIndication) {
                    this.firstErrors.get(e.sceneId.value)?.recordIfNeeded(e.outcome.error);
                    if (!(e.outcome.error instanceof core_1.AssertionError)) {
                        this.printer.println(this.theme.outcome(e.outcome, `${e.outcome.error}`));
                    }
                }
                const artifactGeneratedEvents = this.artifacts.recordedFor(e.activityId);
                if (artifactGeneratedEvents.some(a => a instanceof model_1.LogEntry)) {
                    this.printer.println();
                }
                artifactGeneratedEvents.forEach(artifactGenerated => {
                    if (artifactGenerated.artifact instanceof model_1.LogEntry) {
                        const details = artifactGenerated.artifact.map((artifactContents) => artifactContents.data);
                        if (artifactGenerated.name.value !== details) {
                            this.printer.println(this.theme.log(artifactGenerated.name.value, ':'));
                        }
                        this.printer.println(details);
                        this.printer.println();
                    }
                });
                this.printer.outdent();
                this.printer.outdent();
            })
                .when(events_1.ActivityRelatedArtifactGenerated, (e) => {
                this.artifacts.record(e);
            })
                .when(events_1.TaskFinished, (e) => {
                this.printer.outdent();
                if (e.outcome instanceof model_1.ProblemIndication) {
                    this.printer.indent();
                    this.printer.indent();
                    if (!this.firstErrors.get(e.sceneId.value).alreadyRecorded()) {
                        this.printer.println(this.theme.outcome(e.outcome, this.iconFrom(e.outcome), `${e.outcome.error}`));
                    }
                    this.printer.outdent();
                    this.printer.outdent();
                    this.firstErrors.get(e.sceneId.value).recordIfNeeded(e.outcome.error);
                }
                else if (!(e.outcome instanceof model_1.ExecutionSuccessful)) {
                    this.printer.indent();
                    this.printer.println(this.iconFrom(e.outcome), e.details.name.value);
                    this.printer.outdent();
                }
            })
                .when(events_1.SceneFinished, (e) => {
                this.summary.record(e.details, e.outcome, this.startTimes.eventDurationOf(e));
                this.printer.println();
                this.printer.println(this.theme.outcome(e.outcome, this.formattedOutcome(e, this.deCamelCased(e.outcome.constructor.name))));
                if (e.outcome instanceof model_1.ProblemIndication) {
                    this.printer.println();
                    this.printer.indent();
                    if (e.outcome instanceof model_1.ImplementationPending) {
                        this.printer.println(`${e.outcome.error.name}: ${e.outcome.error.message}`);
                    }
                    else if (e.outcome.error?.stack) {
                        this.printer.println(e.outcome.error.stack);
                    }
                    this.printer.outdent();
                }
                this.artifacts.clear();
            })
                .else((_) => {
                return void 0;
            });
        }
    }
    printSummary(summary) {
        this.printer.println(this.theme.separator('='));
        this.printer.print(this.summaryFormatter.format(summary.aggregated()));
        this.printer.println(this.theme.separator('='));
    }
    isSceneSpecific(event) {
        return Object.prototype.hasOwnProperty.call(event, 'sceneId');
    }
    formattedOutcome(event, description = event.details.name.value) {
        const duration = this.startTimes.eventDurationOf(event);
        const icon = this.iconFrom(event.outcome);
        const message = description.split('\n').map((line, index) => index === 0
            ? `${line} (${duration})`
            : `${' '.repeat(icon.length)}${line}`).join('\n');
        return (event.outcome instanceof model_1.ProblemIndication)
            ? this.theme.outcome(event.outcome, `${icon}${message}`)
            : `${this.theme.outcome(event.outcome, icon)}${message}`;
    }
    deCamelCased(name) {
        const deCamelCased = name.replaceAll(/([^A-Z])([A-Z])/g, '$1 $2');
        return deCamelCased.charAt(0).toUpperCase() + deCamelCased.slice(1).toLocaleLowerCase();
    }
    iconFrom(outcome) {
        switch (outcome.constructor) {
            case model_1.ExecutionCompromised:
            case model_1.ExecutionFailedWithError:
            case model_1.ExecutionFailedWithAssertionError:
                return '✗ ';
            case model_1.ImplementationPending:
                return '☕';
            case model_1.ExecutionSkipped:
                return '⇢ ';
            case model_1.ExecutionIgnored:
                return '? ';
            case model_1.ExecutionSuccessful:
                return '✓ ';
            default:
                return '';
        }
    }
}
exports.ConsoleReporter = ConsoleReporter;
class ConsoleReporterBuilder {
    theme;
    constructor(theme) {
        this.theme = theme;
    }
    build({ stage, outputStream }) {
        return new ConsoleReporter(new Printer_1.Printer(outputStream), this.theme, stage);
    }
}
class StartTimes {
    times = {};
    recordStartOf(event) {
        this.times[this.keyFor(event)] = event.timestamp;
    }
    eventDurationOf(event) {
        if (!this.times[this.keyFor(event)]) {
            throw new core_1.LogicError((0, core_1.d) `StartTime missing for event ${event}`);
        }
        return event.timestamp.diff(this.times[this.keyFor(event)]);
    }
    keyFor(event) {
        return `${event.sceneId.toString()}:${event.activityId?.toString()}`;
    }
}
class FirstError {
    error;
    recordIfNeeded(error) {
        if (!this.error) {
            this.error = error;
        }
    }
    alreadyRecorded() {
        return !!this.error;
    }
    get() {
        return this.error;
    }
}
class ActivityRelatedArtifacts {
    events = [];
    record(event) {
        this.events.push(event);
    }
    recordedFor(activityId) {
        return this.events
            .filter(event => event.activityId.equals(activityId));
    }
    clear() {
        this.events = [];
    }
}
//# sourceMappingURL=ConsoleReporter.js.map