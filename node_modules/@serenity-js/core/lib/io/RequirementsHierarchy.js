"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequirementsHierarchy = void 0;
const errors_1 = require("../errors");
const model_1 = require("../model");
const Path_1 = require("./Path");
class RequirementsHierarchy {
    fileSystem;
    userDefinedSpecDirectory;
    root;
    static specDirectoryCandidates = [
        `features`,
        `specs`,
        `spec`,
        `tests`,
        `test`,
        `src`,
    ];
    constructor(fileSystem, userDefinedSpecDirectory) {
        this.fileSystem = fileSystem;
        this.userDefinedSpecDirectory = userDefinedSpecDirectory;
    }
    requirementTagsFor(pathToSpec, featureName) {
        const [fileBasedFeatureName, capabilityName, ...themeNames] = this.hierarchyFor(pathToSpec).reverse().filter(segment => !['.', '..'].includes(segment));
        const themeTags = themeNames.reverse().map(themeName => model_1.Tag.humanReadable(model_1.ThemeTag, themeName));
        const capabilityTag = capabilityName && model_1.Tag.humanReadable(model_1.CapabilityTag, capabilityName);
        const featureTag = featureName
            ? new model_1.FeatureTag(featureName)
            : model_1.Tag.humanReadable(model_1.FeatureTag, fileBasedFeatureName);
        return [
            ...themeTags,
            capabilityTag,
            featureTag
        ].filter(Boolean);
    }
    hierarchyFor(pathToSpec) {
        const relative = this.rootDirectory().relative(pathToSpec);
        return relative.split().map((segment, i, segments) => {
            // return all the segments as-is, except for the last one
            if (i < segments.length - 1) {
                return segment;
            }
            // Strip the extension, like `.feature` or `.spec.ts`
            const firstDotIndex = segment.indexOf('.');
            return firstDotIndex === -1
                ? segment
                : segment.slice(0, firstDotIndex);
        });
    }
    rootDirectory() {
        if (!this.root) {
            this.root = this.userDefinedSpecDirectory
                ? this.resolve(this.userDefinedSpecDirectory)
                : this.guessRootDirectory();
        }
        return this.root;
    }
    guessRootDirectory() {
        for (const candidate of RequirementsHierarchy.specDirectoryCandidates) {
            const candidateSpecDirectory = Path_1.Path.from(candidate);
            if (this.fileSystem.exists(Path_1.Path.from(candidate))) {
                return this.fileSystem.resolve(candidateSpecDirectory);
            }
        }
        // default to current working directory
        return this.fileSystem.resolve(Path_1.Path.from('.'));
    }
    resolve(userDefinedRootDirectory) {
        if (!this.fileSystem.exists(userDefinedRootDirectory)) {
            throw new errors_1.ConfigurationError(`Configured specDirectory \`${userDefinedRootDirectory}\` does not exist`);
        }
        return this.fileSystem.resolve(userDefinedRootDirectory);
    }
}
exports.RequirementsHierarchy = RequirementsHierarchy;
//# sourceMappingURL=RequirementsHierarchy.js.map