import type { UsesAbilities } from '../abilities';
import type { Actor } from '../Actor';
import type { Answerable } from '../Answerable';
import type { MetaQuestionAdapter, QuestionAdapter } from '../Question';
import { Question } from '../Question';
import type { AnswersQuestions, ChainableMetaQuestion, MetaQuestion } from '../questions';
import { Task } from '../Task';
import type { Expectation } from './Expectation';
/**
 * Serenity/JS Screenplay Pattern-style wrapper around [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
 * and array-like structures - see [`PageElement`](https://serenity-js.org/api/web/class/PageElements/).
 *
 * @group Questions
 */
export declare abstract class List<Item_Type> extends Question<Promise<Array<Item_Type>>> {
    protected readonly collection: Answerable<Array<Item_Type>>;
    protected subject?: string;
    static of<IT, CT, RQT extends (Question<Promise<Array<IT>>> | Question<Array<IT>>)>(collection: Answerable<Array<IT>> & ChainableMetaQuestion<CT, RQT>): MetaList<CT, IT>;
    static of<IT>(collection: Answerable<Array<IT>>): List<IT>;
    constructor(collection: Answerable<Array<Item_Type>>);
    forEach(callback: (current: CurrentItem<Item_Type>, index: number, items: Array<Item_Type>) => Promise<void> | void): Task;
    abstract eachMappedTo<Mapped_Item_Type>(question: MetaQuestion<Item_Type, Question<Promise<Mapped_Item_Type> | Mapped_Item_Type>>): List<Mapped_Item_Type>;
    abstract where<Answer_Type>(question: MetaQuestion<Item_Type, Question<Promise<Answer_Type> | Answer_Type>>, expectation: Expectation<Answer_Type>): List<Item_Type>;
    abstract count(): QuestionAdapter<number>;
    abstract first(): QuestionAdapter<Item_Type>;
    abstract last(): QuestionAdapter<Item_Type>;
    abstract nth(index: number): QuestionAdapter<Item_Type>;
    answeredBy(actor: AnswersQuestions & UsesAbilities): Promise<Array<Item_Type>>;
    /**
     * @param {number} index
     */
    protected ordinal(index: number): string;
}
/**
 * Serenity/JS Screenplay Pattern-style wrapper around
 * a [`ChainableMetaQuestion`](https://serenity-js.org/api/core/interface/ChainableMetaQuestion/) representing a collection
 * that can be resolved in `Supported_Context_Type` of another [`Question`](https://serenity-js.org/api/core/class/Question/).
 *
 * For example, [`PageElements.located`](https://serenity-js.org/api/web/class/PageElements/#located) returns `MetaList<PageElement>`,
 * which allows for the collection of page elements to be resolved in the context
 * of dynamically-provided root element.
 *
 * ```typescript
 * import { By, PageElements, PageElement } from '@serenity-js/web'
 *
 * const firstLabel = () =>
 *   PageElements.located(By.css('label'))
 *      .first()
 *      .describedAs('first label')
 *
 * const exampleForm = () =>
 *   PageElement.located(By.css('form#example1'))
 *      .describedAs('example form')
 *
 * const anotherExampleForm = () =>
 *   PageElement.located(By.css('form#example2'))
 *      .describedAs('another example form')
 *
 * // Next, you can compose the above questions dynamically with various "contexts":
 * //   firstLabel().of(exampleForm())
 * //   firstLabel().of(anotherExampleForm())
 * ```
 *
 * @group Questions
 */
export declare class MetaList<Supported_Context_Type, Item_Type> extends List<Item_Type> implements ChainableMetaQuestion<Supported_Context_Type, MetaList<Supported_Context_Type, Item_Type>> {
    protected readonly collection: Answerable<Array<Item_Type>> & ChainableMetaQuestion<Supported_Context_Type, Question<Promise<Array<Item_Type>>> | Question<Array<Item_Type>>>;
    constructor(collection: Answerable<Array<Item_Type>> & ChainableMetaQuestion<Supported_Context_Type, Question<Promise<Array<Item_Type>>> | Question<Array<Item_Type>>>);
    of(context: Answerable<Supported_Context_Type>): MetaList<Supported_Context_Type, Item_Type>;
    eachMappedTo<Mapped_Item_Type>(question: MetaQuestion<Item_Type, Question<Promise<Mapped_Item_Type> | Mapped_Item_Type>>): MetaList<Supported_Context_Type, Mapped_Item_Type>;
    where<Answer_Type>(question: MetaQuestion<Item_Type, Question<Promise<Answer_Type> | Answer_Type>>, expectation: Expectation<Answer_Type>): MetaList<Supported_Context_Type, Item_Type>;
    count(): MetaQuestionAdapter<Supported_Context_Type, number>;
    first(): MetaQuestionAdapter<Supported_Context_Type, Item_Type>;
    last(): MetaQuestionAdapter<Supported_Context_Type, Item_Type>;
    nth(index: number): MetaQuestionAdapter<Supported_Context_Type, Item_Type>;
}
/**
 * @group Questions
 */
export interface CurrentItem<Item_Type> {
    item: Item_Type;
    actor: Actor;
}
//# sourceMappingURL=List.d.ts.map