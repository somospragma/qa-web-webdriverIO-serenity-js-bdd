"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.the = the;
exports.q = q;
const io_1 = require("../../io");
const Question_1 = require("../Question");
const Describable_1 = require("./Describable");
function the(...args) {
    if (io_1.ValueInspector.isPlainObject(args[0])) {
        const descriptionFormattingOptions = args[0];
        return (templates, ...parameters) => templateToQuestion(templates, parameters, createParameterToDescriptionMapper(descriptionFormattingOptions), createParameterValueToDescriptionMapper(descriptionFormattingOptions));
    }
    return templateToQuestion(args[0], args.slice(1), createParameterToDescriptionMapper(), createParameterValueToDescriptionMapper());
}
/**
 * A Serenity/JS Screenplay Pattern-flavour
 * of a [tagged template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates),
 * `q` is a tag function capable of resolving any `Answerable<string>` or `Answerable<number>`
 * you parametrise it with, and returning a `QuestionAdapter<string>`.
 *
 * Use `q` to concatenate `string` and `number` values returned from synchronous an asynchronous sources.
 *
 * ## Interpolating questions
 *
 * ```ts
 * import { q, actorCalled } from '@serenity-js/core'
 * import { Send, DeleteRequest } from '@serenity-js/rest'
 * import { Text } from '@serenity-js/web'
 *
 * await actorCalled('Alice').attemptsTo(
 *   Send.a(DeleteRequest.to(
 *     q `/articles/${ Text.of(Article.id()) }`
 *   ))
 * )
 * ```
 *
 * ## Using a custom description
 *
 * ```ts
 * import { q, actorCalled } from '@serenity-js/core'
 * import { Send, DeleteRequest } from '@serenity-js/rest'
 *
 * await actorCalled('Alice').attemptsTo(
 *   Send.a(DeleteRequest.to(
 *     q `/articles/${ Text.of(Article.id()) }`.describedAs('/articles/:id')
 *   ))
 * )
 * ```
 *
 * ## Transforming the interpolated string
 *
 * The mechanism presented below relies on [`QuestionAdapter`](https://serenity-js.org/api/core/#QuestionAdapter).
 *
 * ```ts
 * import { q, actorCalled } from '@serenity-js/core'
 * import { Send, DeleteRequest } from '@serenity-js/rest'
 *
 * await actorCalled('Alice').attemptsTo(
 *   Send.a(DeleteRequest.to(
 *     q `/articles/${ Text.of(Article.id()) }`.toLocaleLowerCase()
 *   ))
 * )
 * ```
 *
 * ## Learn more
 *
 * - [`Answerable`](https://serenity-js.org/api/core/#Answerable)
 * - [`Question`](https://serenity-js.org/api/core/class/Question/)
 * - [`Question.describedAs`](https://serenity-js.org/api/core/class/Question/#describedAs)
 * - [`QuestionAdapter`](https://serenity-js.org/api/core/#QuestionAdapter)
 *
 * @group Questions
 *
 * @param templates
 * @param parameters
 */
function q(templates, ...parameters) {
    return templateToQuestion(templates, parameters, (parameter) => {
        // return static string and number parameter values as is
        if (typeof parameter === 'string' || typeof parameter === 'number') {
            return String(parameter);
        }
        // for Questions, Promises and other Answerables, return their description
        return `{${createParameterToDescriptionMapper()(parameter)}}`;
    }, createParameterValueMapper());
}
function createParameterToDescriptionMapper(options) {
    return (parameter) => parameter === undefined
        ? 'undefined'
        : Question_1.Question.formattedValue(options).of(parameter).toString();
}
function createParameterValueToDescriptionMapper(options) {
    return async (actor, parameter) => parameter instanceof Describable_1.Describable
        ? parameter.describedBy(actor)
        : actor.answer(Question_1.Question.formattedValue(options).of(parameter));
}
function createParameterValueMapper() {
    return async (actor, parameter) => actor.answer(parameter);
}
function templateToQuestion(templates, parameters, descriptionMapper, valueMapper) {
    const description = interpolate(templates, parameters.map(parameter => descriptionMapper(parameter)));
    return Question_1.Question.about(description, async (actor) => {
        const descriptions = await (0, io_1.asyncMap)(parameters, parameter => valueMapper(actor, parameter));
        return interpolate(templates, descriptions);
    }, (context) => templateToQuestion(templates, parameters.map(parameter => Question_1.Question.isAMetaQuestion(parameter)
        ? parameter.of(context)
        : parameter), descriptionMapper, valueMapper));
}
function interpolate(templates, parameters) {
    return templates.flatMap((template, i) => i < parameters.length
        ? [template, parameters[i]]
        : [template]).join('');
}
//# sourceMappingURL=tag-functions.js.map