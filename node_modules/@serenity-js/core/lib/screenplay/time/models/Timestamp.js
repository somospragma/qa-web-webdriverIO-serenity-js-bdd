"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timestamp = void 0;
const tiny_types_1 = require("tiny-types");
const util_1 = require("util");
const Duration_1 = require("./Duration");
/**
 * Represents a point in time.
 *
 * `Timestamp` makes it easier for you to work with information related to time, like [Serenity/JS domain events](https://serenity-js.org/api/core-events/class/DomainEvent/).
 *
 * ## Learn more
 * - [`Duration`](https://serenity-js.org/api/core/class/Duration/)
 * - [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
 *
 * @group Time
 */
class Timestamp extends tiny_types_1.TinyType {
    value;
    static fromJSON(v) {
        return new Timestamp(new Date((0, tiny_types_1.ensure)(Timestamp.name, v, isSerialisedISO8601Date())));
    }
    static fromTimestampInSeconds(value) {
        return Timestamp.fromTimestampInMilliseconds(value * 1000);
    }
    static fromTimestampInMilliseconds(value) {
        return new Timestamp(new Date(value));
    }
    static now() {
        return new Timestamp();
    }
    constructor(value = new Date()) {
        super();
        this.value = value;
        (0, tiny_types_1.ensure)(Timestamp.name, value, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isInstanceOf)(Date));
    }
    diff(another) {
        (0, tiny_types_1.ensure)('timestamp', another, (0, tiny_types_1.isDefined)());
        return new Duration_1.Duration(Math.abs(this.toMilliseconds() - another.toMilliseconds()));
    }
    plus(duration) {
        (0, tiny_types_1.ensure)('duration', duration, (0, tiny_types_1.isDefined)());
        return new Timestamp(new Date(this.toMilliseconds() + duration.inMilliseconds()));
    }
    less(duration) {
        (0, tiny_types_1.ensure)('duration', duration, (0, tiny_types_1.isDefined)());
        return new Timestamp(new Date(this.toMilliseconds() - duration.inMilliseconds()));
    }
    isBefore(another) {
        (0, tiny_types_1.ensure)('timestamp', another, (0, tiny_types_1.isDefined)());
        return this.value.getTime() < another.value.getTime();
    }
    isBeforeOrEqual(another) {
        (0, tiny_types_1.ensure)('timestamp', another, (0, tiny_types_1.isDefined)());
        return this.value.getTime() <= another.value.getTime();
    }
    isAfter(another) {
        (0, tiny_types_1.ensure)('timestamp', another, (0, tiny_types_1.isDefined)());
        return this.value.getTime() > another.value.getTime();
    }
    isAfterOrEqual(another) {
        (0, tiny_types_1.ensure)('timestamp', another, (0, tiny_types_1.isDefined)());
        return this.value.getTime() >= another.value.getTime();
    }
    toMilliseconds() {
        return this.value.getTime();
    }
    toSeconds() {
        return Math.floor(this.toMilliseconds() / 1_000);
    }
    toJSON() {
        return this.value.toJSON();
    }
    toISOString() {
        return this.value.toISOString();
    }
    toString() {
        return this.toISOString();
    }
    [util_1.inspect.custom]() {
        return `Timestamp(${this.value.toISOString()})`;
    }
}
exports.Timestamp = Timestamp;
/**
 * Based on the implementation by Brock Adams:
 * - https://stackoverflow.com/a/3143231/264502 by Brock Adams
 * - https://www.w3.org/TR/NOTE-datetime
 */
function isSerialisedISO8601Date() {
    const yyyyMMdd = `\\d{4}-[01]\\d-[0-3]\\d`;
    const hh = `[0-2]\\d`;
    const mm = `[0-5]\\d`;
    const ss = `[0-5]\\d`;
    const ms = `\\d+`;
    const T = `[Tt\\s]`;
    const offset = `[+-]${hh}:${mm}|Z`;
    const pattern = new RegExp('^' + [
        // Full precision - YYYY-MM-DDThh:mm:ss.sss
        `(${yyyyMMdd}${T}${hh}:${mm}:${ss}\\.${ms}(${offset})?)`,
        // No milliseconds - YYYY-MM-DDThh:mm:ss
        `(${yyyyMMdd}${T}${hh}:${mm}:${ss}(${offset})?)`,
        // No seconds - YYYY-MM-DDThh:mm
        `(${yyyyMMdd}${T}${hh}:${mm}(${offset})?)`,
        // Just the date - YYYY-MM-DD
        `(${yyyyMMdd})`,
    ].join('|') + '$');
    return tiny_types_1.Predicate.to(`follow the ISO8601 format: YYYY-MM-DD[Thh:mm[:ss[.sss]]]`, (value) => {
        if (!pattern.test(value)) {
            return false;
        }
        const date = new Date(value);
        return date instanceof Date
            && !Number.isNaN(date.getTime());
    });
}
//# sourceMappingURL=Timestamp.js.map