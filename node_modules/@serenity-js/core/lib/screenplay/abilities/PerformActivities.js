"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformActivities = void 0;
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../../errors");
const events_1 = require("../../events");
const io_1 = require("../../io");
const model_1 = require("../../model");
const Interaction_1 = require("../Interaction");
const Ability_1 = require("./Ability");
/**
 * An [`Ability`](https://serenity-js.org/api/core/class/Ability/) that enables an [`Actor`](https://serenity-js.org/api/core/class/Actor/) to perform a given [`Activity`](https://serenity-js.org/api/core/class/Activity/).
 *
 * [`PerformActivities`](https://serenity-js.org/api/core/class/PerformActivities/) is used internally by [`Actor.attemptsTo`](https://serenity-js.org/api/core/class/Actor/#attemptsTo), and it is unlikely you'll ever need to use it directly in your code.
 * That is, unless you're building a custom Serenity/JS extension and want to override the default behaviour of the framework,
 * in which case you should check out the [Contributor's Guide](https://serenity-js.org/community/contributing).
 *
 * @group Abilities
 */
class PerformActivities extends Ability_1.Ability {
    actor;
    stage;
    constructor(actor, stage) {
        super();
        this.actor = actor;
        this.stage = stage;
    }
    async perform(activity) {
        const sceneId = this.stage.currentSceneId();
        const details = this.detailsOf(this.nameOf(activity), activity.instantiationLocation());
        const activityId = this.stage.assignNewActivityId(details);
        const [activityStarts, activityFinished] = activity instanceof Interaction_1.Interaction
            ? [events_1.InteractionStarts, events_1.InteractionFinished]
            : [events_1.TaskStarts, events_1.TaskFinished];
        try {
            this.stage.announce(new activityStarts(sceneId, activityId, details, this.stage.currentTime()));
            await activity.performAs(this.actor);
            const name = await activity.describedBy(this.actor);
            this.stage.announce(new activityFinished(sceneId, activityId, this.detailsOf(name, activity.instantiationLocation()), new model_1.ExecutionSuccessful(), this.stage.currentTime()));
        }
        catch (error) {
            this.stage.announce(new activityFinished(sceneId, activityId, details, this.outcomeFor(error), this.stage.currentTime()));
            throw error;
        }
        finally {
            await this.stage.waitForNextCue();
        }
    }
    outcomeFor(error) {
        return (0, tiny_types_1.match)(error)
            .when(errors_1.ImplementationPendingError, _ => new model_1.ImplementationPending(error))
            .when(errors_1.TestCompromisedError, _ => new model_1.ExecutionCompromised(error))
            .when(errors_1.AssertionError, _ => new model_1.ExecutionFailedWithAssertionError(error))
            .when(Error, _ => /AssertionError/.test(error.constructor.name) // mocha
            ? new model_1.ExecutionFailedWithAssertionError(error)
            : new model_1.ExecutionFailedWithError(error))
            .else(_ => new model_1.ExecutionFailedWithError(error));
    }
    detailsOf(name, instantiationLocation) {
        return new model_1.ActivityDetails(new model_1.Name(name), instantiationLocation);
    }
    nameOf(activity) {
        const template = io_1.ValueInspector.hasItsOwnToString(activity)
            ? activity.toString()
            : `#actor performs ${activity.constructor.name}`;
        return template.replaceAll('#actor', this.actor.name);
    }
}
exports.PerformActivities = PerformActivities;
//# sourceMappingURL=PerformActivities.js.map