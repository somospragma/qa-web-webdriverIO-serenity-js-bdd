"use strict";
const messages_1 = require("@cucumber/messages");
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const CucumberMessagesParser_1 = require("./parser/CucumberMessagesParser");
module.exports = function (serenity, moduleLoader) {
    const { Formatter, formatterHelpers } = moduleLoader.require('@cucumber/cucumber'), TestCaseHookDefinition = moduleLoader.require('@cucumber/cucumber/lib/models/test_case_hook_definition').default;
    return class CucumberMessagesListener extends Formatter {
        static fakeInternalAfterHookUri = '/internal/serenity-js/cucumber';
        parser;
        log;
        supportCodeLibrary;
        constructor(options) {
            super(options);
            this.parser = new CucumberMessagesParser_1.CucumberMessagesParser(serenity, formatterHelpers, options, (step) => step?.actionLocation?.uri !== CucumberMessagesListener.fakeInternalAfterHookUri);
            this.supportCodeLibrary = this.supportCodeLibrary ?? options.supportCodeLibrary;
            this.addAfterHook(() => {
                this.emit(new events_1.SceneFinishes(serenity.currentSceneId(), serenity.currentTime()));
                return serenity.waitForNextCue();
            });
            options.eventBroadcaster.on('envelope', (envelope) => {
                // this.log('> [cucumber] ' + JSON.stringify(envelope) + '\n');
                switch (true) {
                    case !!envelope.testRunStarted:
                        return this.emit(new events_1.TestRunStarts(serenity.currentTime()));
                    case !!envelope.testCaseStarted:
                        return this.emit(this.parser.parseTestCaseStarted(envelope.testCaseStarted));
                    case !!envelope.testStepStarted:
                        return this.emit(this.parser.parseTestStepStarted(envelope.testStepStarted));
                    case !!envelope.testStepFinished:
                        return this.emit(this.parser.parseTestStepFinished(envelope.testStepFinished));
                    case !!envelope.testCaseFinished:
                        return this.emit(this.parser.parseTestCaseFinished(envelope.testCaseFinished));
                }
            });
        }
        async finished() {
            this.emit(new events_1.TestRunFinishes(serenity.currentTime()));
            try {
                await serenity.waitForNextCue();
                this.emit(new events_1.TestRunFinished(new model_1.ExecutionSuccessful(), serenity.currentTime()));
            }
            catch (error) {
                this.emit(new events_1.TestRunFinished(new model_1.ExecutionFailedWithError(error), serenity.currentTime()));
                throw error;
            }
            finally {
                await super.finished();
            }
        }
        addAfterHook(code) {
            this.supportCodeLibrary.afterTestCaseHookDefinitions.unshift(new TestCaseHookDefinition({
                code,
                id: messages_1.IdGenerator.uuid()(),
                line: 0,
                uri: CucumberMessagesListener.fakeInternalAfterHookUri,
                options: {},
            }));
        }
        emit(events) {
            [].concat(events).forEach(event => serenity.announce(event));
        }
    };
};
//# sourceMappingURL=CucumberMessagesListener.js.map