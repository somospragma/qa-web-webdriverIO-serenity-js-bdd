"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Failsafe = void 0;
const child_process_1 = require("child_process");
const fs = require("fs");
const readline = require("readline");
const path = require("path");
const ArgumentParser_1 = require("./ArgumentParser");
const logger_1 = require("./logger");
const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8'));
class Failsafe {
    constructor(logger, config, env) {
        this.logger = logger;
        this.config = config;
        this.env = env;
        this.parser = new ArgumentParser_1.ArgumentParser();
    }
    async help() {
        this.logger.help((0, logger_1.trimmed) `
            | Usage: failsafe [options]
            | 
            | Description:
            |    Executes a sequence of npm scripts and returns
            |    the correct exit code should any of them fail.
            | 
            | Example:
            |    Given you have the following npm scripts defined:
            |        "scripts": {
            |            "clean": "rimraf target",
            |            "test": "failsafe clean test:playwright [--spec,...] test:report [--destination]",
            |            "test:playwright": "playwright test",
            |            "test:report": "serenity-bdd run",
            |        }
            | 
            |    When you run the following command:
            |        npm run test -- --spec "spec/**/*.spec.ts" --destination=reports
            | 
            |    Then all the following commands are executed in a sequence
            |    and the highest exit code is returned:
            |        1. rimraf target
            |        2. playwright test --spec spec/**/*.spec.ts
            |        3. serenity-bdd run --destination=reports
            | 
            | Info:
            |   Version: ${packageJson.version}
            |   Author: ${packageJson.author}
            |   License: ${packageJson.license}
            |   Homepage: ${packageJson.homepage}
            |`);
        return 0;
    }
    async run(arguments_) {
        if (arguments_.length === 1 && ['--help', '-help', '-h', '-usage', '--usage'].includes(arguments_[0])) {
            return this.help();
        }
        try {
            const scripts = this.parser.parse(arguments_);
            if (scripts.length === 0) {
                this.logger.error('failsafe', (0, logger_1.trimmed) `
                | Please specify which npm scripts you'd like to run, for example:
                |   npm failsafe start test
                |`);
                return 1;
            }
            const result = await this.runScripts(scripts);
            this.logger.info('failsafe', this.summaryOf(result));
            return result.exitCode;
        }
        catch (error) {
            if (error instanceof ArgumentParser_1.ParseError) {
                this.logger.error('failsafe', (0, logger_1.trimmed) `
                    | Error: ${error.message} at position ${error.position}:
                    |   ${error.parsed}
                    |   ${'-'.repeat(Math.max(0, error.position - 1))}^
                    |`);
            }
            else if (error instanceof ArgumentParser_1.UnrecognisedArgumentsError) {
                this.logger.error('failsafe', (0, logger_1.trimmed) `
                    | Error: ${error.message}
                    | Notice: To configure your project to recognize them you might want
                    |         to change your package.json scripts to something like:
                    |             "scripts": {
                    |                 "script": "${error.recommendedScript}",
                    |             }
                    |         For details see: ${packageJson.homepage}
                    |`);
            }
            else {
                this.logger.error('failsafe', `Error: ${error.message}`);
            }
            return 1;
        }
    }
    summaryOf(result) {
        const plural = result.failedScripts.length > 1;
        return result.failedScripts.length === 0
            ? `Succeeded with exit code ${result.exitCode} as all scripts passed`
            : `Failed with exit code ${result.exitCode} due to failing script${plural ? 's' : ''}: ${result.failedScripts.map(s => `'${s}'`).join(', ')}`;
    }
    async runScripts(scripts) {
        return await scripts.reduce(async (previous, script) => {
            const result = await previous;
            const currentExitCode = await this.runScript(script.name, script.arguments);
            result.exitCode = Math.max(result.exitCode, currentExitCode);
            if (currentExitCode !== 0) {
                result.failedScripts.push(script.name);
            }
            return result;
        }, Promise.resolve({ exitCode: 0, failedScripts: [] }));
    }
    runScript(scriptName, arguments_ = []) {
        return new Promise((resolve, reject) => {
            const isWindows = process.platform.startsWith('win32');
            const npmArguments = [`run`, scriptName];
            if (arguments_.length > 0) {
                npmArguments.push('--', ...arguments_);
            }
            const script = isWindows
                ? this.windowsSpawn(npmArguments)
                : this.linuxAndMacSpawn(npmArguments);
            const stdout = readline.createInterface({ input: script.stdout }), stderr = readline.createInterface({ input: script.stderr });
            stdout.on('line', line => this.logger.info(scriptName, line));
            stderr.on('line', line => this.logger.error(scriptName, line));
            script.once('close', (code) => {
                stdout.close();
                stderr.close();
                this.logger.info('failsafe', `Script '${scriptName}' exited with code ${code}`);
                resolve(code ?? 0);
            });
        });
    }
    linuxAndMacSpawn(npmArguments) {
        const npm = process.env.npm_execpath ?? `npm`;
        return (0, child_process_1.spawn)(npm, npmArguments, {
            cwd: this.config.cwd,
            env: {
                ...this.forceColorEnv(),
                ...this.env
            },
        });
    }
    windowsSpawn(npmArguments) {
        /* c8 ignore start */
        return (0, child_process_1.spawn)(`npm.cmd`, npmArguments.map(npmArgument => this.quoteArgumentsWithSpaces(npmArgument)), {
            cwd: this.config.cwd,
            env: {
                ...this.forceColorEnv(),
                ...this.env
            },
            shell: true,
        });
        /* c8 ignore stop */
    }
    quoteArgumentsWithSpaces(npmArgument) {
        /* c8 ignore start */
        return npmArgument.includes(' ')
            ? `"${npmArgument}"`
            : npmArgument;
        /* c8 ignore stop */
    }
    forceColorEnv() {
        return {
            'FORCE_COLOR': this.config.isTTY ? '1' : undefined,
        };
    }
}
exports.Failsafe = Failsafe;
//# sourceMappingURL=Failsafe.js.map